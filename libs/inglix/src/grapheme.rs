use serde::{Deserialize, Serialize};

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[serde(try_from = "char")]
pub enum Grapheme {
	a,
	b,
	c,
	d,
	e,
	E,
	f,
	g,
	J,
	h,
	i,
	j,
	k,
	l,
	m,
	n,
	o,
	O,
	p,
	r,
	s,
	S,
	t,
	T,
	u,
	U,
	H,
	v,
	w,
	x,
	y,
	z,
}

impl Grapheme {
	pub fn name(&self) -> String {
		match self {
			Self::a => String::from("eE"),
			Self::b => String::from("bE"),
			Self::c => String::from("sE"),
			Self::d => String::from("dE"),
			Self::e => String::from("E"),
			Self::E => String::from("mE"),
			Self::f => String::from("ef"),
			Self::g => String::from("jE"),
			Self::J => String::from("JE"),
			Self::h => String::from("eEc"),
			Self::i => String::from("aE"),
			Self::j => String::from("jeE"),
			Self::k => String::from("keE"),
			Self::l => String::from("el"),
			Self::m => String::from("em"),
			Self::n => String::from("en"),
			Self::o => String::from("O"),
			Self::O => String::from("nO"),
			Self::p => String::from("pE"),
			Self::r => String::from("ar"),
			Self::s => String::from("es"),
			Self::S => String::from("eS"),
			Self::t => String::from("tE"),
			Self::T => String::from("TE"),
			Self::u => String::from("yU"),
			Self::U => String::from("hU"),
			Self::H => String::from("hHm"),
			Self::v => String::from("vE"),
			Self::w => String::from("dHblyU"),
			Self::x => String::from("eks"),
			Self::y => String::from("waE"),
			Self::z => String::from("zE"),
		}
	}
}

impl TryFrom<char> for Grapheme {
	type Error = String;

	fn try_from(c: char) -> Result<Self, Self::Error> {
		match c {
			'a' => Ok(Self::a),
			'b' => Ok(Self::b),
			'c' => Ok(Self::c),
			'd' => Ok(Self::d),
			'e' => Ok(Self::e),
			'E' => Ok(Self::E),
			'f' => Ok(Self::f),
			'g' => Ok(Self::g),
			'J' => Ok(Self::J),
			'h' => Ok(Self::h),
			'i' => Ok(Self::i),
			'j' => Ok(Self::j),
			'k' => Ok(Self::k),
			'l' => Ok(Self::l),
			'm' => Ok(Self::m),
			'n' => Ok(Self::n),
			'o' => Ok(Self::o),
			'O' => Ok(Self::O),
			'p' => Ok(Self::p),
			'r' => Ok(Self::r),
			's' => Ok(Self::s),
			'S' => Ok(Self::S),
			't' => Ok(Self::t),
			'T' => Ok(Self::T),
			'u' => Ok(Self::u),
			'U' => Ok(Self::U),
			'H' => Ok(Self::H),
			'v' => Ok(Self::v),
			'w' => Ok(Self::w),
			'x' => Ok(Self::x),
			'y' => Ok(Self::y),
			'z' => Ok(Self::z),
			_ => Err(format!("Invalid grapheme initialization '{}'", c)),
		}
	}
}

impl From<Grapheme> for char {
	fn from(grapheme: Grapheme) -> Self {
		match grapheme {
			Grapheme::a => 'a',
			Grapheme::b => 'b',
			Grapheme::c => 'c',
			Grapheme::d => 'd',
			Grapheme::e => 'e',
			Grapheme::E => 'E',
			Grapheme::f => 'f',
			Grapheme::g => 'g',
			Grapheme::J => 'J',
			Grapheme::h => 'h',
			Grapheme::i => 'i',
			Grapheme::j => 'j',
			Grapheme::k => 'k',
			Grapheme::l => 'l',
			Grapheme::m => 'm',
			Grapheme::n => 'n',
			Grapheme::o => 'o',
			Grapheme::O => 'O',
			Grapheme::p => 'p',
			Grapheme::r => 'r',
			Grapheme::s => 's',
			Grapheme::S => 'S',
			Grapheme::t => 't',
			Grapheme::T => 'T',
			Grapheme::u => 'u',
			Grapheme::U => 'U',
			Grapheme::H => 'H',
			Grapheme::v => 'v',
			Grapheme::w => 'w',
			Grapheme::x => 'x',
			Grapheme::y => 'y',
			Grapheme::z => 'z',
		}
	}
}
